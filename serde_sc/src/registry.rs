use crate::{SerdeSchema, expr::TypeExpr};
use std::{
    any::TypeId,
    collections::{HashMap, HashSet},
};

/// The `Registry` struct holds a mapping from `TypeId` to `TypeExpr`, allowing fast lookup
/// of type information registered by the schema system.
#[derive(Debug)]
pub struct Registry {
    state: HashMap<TypeId, TypeExpr>,
}

impl Default for Registry {
    fn default() -> Self {
        Self::new()
    }
}

impl Registry {
    /// Creates a new, empty `Registry`.
    pub fn new() -> Self {
        Self {
            state: HashMap::new(),
        }
    }

    fn try_insert_with(&mut self, type_id: TypeId, type_expr_fn: impl Fn() -> TypeExpr) {
        if self.state.contains_key(&type_id) {
            return;
        }
        self.state.insert(type_id, type_expr_fn());
    }

    /// Shorthand for calling `T::on_register(self)` for the given type `T`.
    pub fn register<T>(&mut self)
    where
        T: SerdeSchema + 'static,
    {
        T::on_register(&mut RegistryContext {
            registry: self,
            pending: HashSet::new(),
        });
    }

    /// Returns a reference to the `TypeExpr` associated with the given `type_id`, if it exists.
    pub fn get(&self, type_id: TypeId) -> Option<&TypeExpr> {
        self.state.get(&type_id)
    }

    /// Returns an iterator over all registered `(TypeId, TypeExpr)` pairs.
    pub fn iter(&self) -> impl Iterator<Item = (&TypeId, &TypeExpr)> {
        self.state.iter()
    }
}

/// `RegistryContext` provides contextual access to a `Registry`
/// and tracks currently pending type registrations to prevent cycles.
pub struct RegistryContext<'a> {
    registry: &'a mut Registry,
    pending: HashSet<TypeId>,
}

impl<'a> RegistryContext<'a> {
    /// Returns whether `T` is currently being registered (cycle breaker).
    pub fn is_pending<T: ?Sized + 'static>(&self) -> bool {
        self.pending.contains(&TypeId::of::<T>())
    }

    /// Marks `T` as pending (true) or clears it (false).
    pub fn set_pending<T: ?Sized + 'static>(&mut self, pending: bool) {
        let type_id = TypeId::of::<T>();
        if pending {
            self.pending.insert(type_id);
        } else {
            self.pending.remove(&type_id);
        }
    }

    /// Tries to insert a new `TypeExpr` generated by `type_expr_fn` for the given `type_id` if it does not already exist.
    pub fn try_insert_with(&mut self, type_id: TypeId, type_expr_fn: impl Fn() -> TypeExpr) {
        self.registry.try_insert_with(type_id, type_expr_fn);
    }
}
